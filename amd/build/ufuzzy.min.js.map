{"version":3,"file":"ufuzzy.min.js","sources":["../src/ufuzzy.js"],"sourcesContent":["/**\n * Copyright (c) 2024, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * uFuzzy.js (μFuzzy)\n * A tiny, efficient fuzzy matcher that doesn't suck\n * https://github.com/leeoniya/uFuzzy (v1.0.14)\n */\n/* eslint-disable */\nvar uFuzzy = (function () {\n    'use strict';\n\n    const cmp = new Intl.Collator('en', { numeric: true, sensitivity: 'base' }).compare;\n\n    const inf = Infinity;\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#escaping\n    const escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n    // meh, magic tmp placeholder, must be tolerant to toLocaleLowerCase(), interSplit, and intraSplit\n    const EXACT_HERE = 'eexxaacctt';\n\n    const PUNCT_RE = /\\p{P}/gu;\n\n    const LATIN_UPPER = 'A-Z';\n    const LATIN_LOWER = 'a-z';\n\n    const swapAlpha = (str, upper, lower) => str.replace(LATIN_UPPER, upper).replace(LATIN_LOWER, lower);\n\n    const OPTS = {\n        // whether regexps use a /u unicode flag\n        unicode: false,\n\n        alpha: null,\n\n        // term segmentation & punct/whitespace merging\n        interSplit: \"[^A-Za-z\\\\d']+\",\n        intraSplit: \"[a-z][A-Z]\",\n\n        // inter bounds that will be used to increase lft2/rgt2 info counters\n        interBound: \"[^A-Za-z\\\\d]\",\n        // intra bounds that will be used to increase lft1/rgt1 info counters\n        intraBound: \"[A-Za-z]\\\\d|\\\\d[A-Za-z]|[a-z][A-Z]\",\n\n        // inter-bounds mode\n        // 2 = strict (will only match 'man' on whitepace and punct boundaries: Mega Man, Mega_Man, mega.man)\n        // 1 = loose  (plus allowance for alpha-num and case-change boundaries: MegaMan, 0007man)\n        // 0 = any    (will match 'man' as any substring: megamaniac)\n        interLft: 0,\n        interRgt: 0,\n\n        // allowance between terms\n        interChars: '.',\n        interIns: inf,\n\n        // allowance between chars in terms\n        intraChars: \"[a-z\\\\d']\", // internally case-insensitive\n        intraIns: null,\n\n        intraContr: \"'[a-z]{1,2}\\\\b\",\n\n        // multi-insert or single-error mode\n        intraMode: 0,\n\n        // single-error bounds for errors within terms, default requires exact first char\n        intraSlice: [1, inf],\n\n        // single-error tolerance toggles\n        intraSub: null,\n        intraTrn: null,\n        intraDel: null,\n\n        // can post-filter matches that are too far apart in distance or length\n        // (since intraIns is between each char, it can accum to nonsense matches)\n        intraFilt: (term, match, index) => true, // should this also accept WIP info?\n\n        // final sorting fn\n        sort: (info, haystack, needle) => {\n            let {\n                idx,\n                chars,\n                terms,\n                interLft2,\n                interLft1,\n                //\tinterRgt2,\n                //\tinterRgt1,\n                start,\n                intraIns,\n                interIns,\n            } = info;\n\n            return idx.map((v, i) => i).sort((ia, ib) => (\n                // most contig chars matched\n                chars[ib] - chars[ia] ||\n                // least char intra-fuzz (most contiguous)\n                intraIns[ia] - intraIns[ib] ||\n                // most prefix bounds, boosted by full term matches\n                (\n                    (terms[ib] + interLft2[ib] + 0.5 * interLft1[ib]) -\n                    (terms[ia] + interLft2[ia] + 0.5 * interLft1[ia])\n                ) ||\n                // highest density of match (least span)\n                //\tspan[ia] - span[ib] ||\n                // highest density of match (least term inter-fuzz)\n                interIns[ia] - interIns[ib] ||\n                // earliest start of match\n                start[ia] - start[ib] ||\n                // alphabetic\n                cmp(haystack[idx[ia]], haystack[idx[ib]])\n            ));\n        },\n    };\n\n    const lazyRepeat = (chars, limit) => (\n        limit == 0   ? ''           :\n            limit == 1   ? chars + '??' :\n                limit == inf ? chars + '*?' :\n                    chars + `{0,${limit}}?`\n    );\n\n    const mode2Tpl = '(?:\\\\b|_)';\n\n    function uFuzzy(opts) {\n        opts = Object.assign({}, OPTS, opts);\n\n        let {\n            unicode,\n            interLft,\n            interRgt,\n            intraMode,\n            intraSlice,\n            intraIns,\n            intraSub,\n            intraTrn,\n            intraDel,\n            intraContr,\n            intraSplit: _intraSplit,\n            interSplit: _interSplit,\n            intraBound: _intraBound,\n            interBound: _interBound,\n            intraChars,\n        } = opts;\n\n        intraIns ??= intraMode;\n        intraSub ??= intraMode;\n        intraTrn ??= intraMode;\n        intraDel ??= intraMode;\n\n        let alpha = opts.letters ?? opts.alpha;\n\n        if (alpha != null) {\n            let upper = alpha.toLocaleUpperCase();\n            let lower = alpha.toLocaleLowerCase();\n\n            _interSplit = swapAlpha(_interSplit, upper, lower);\n            _intraSplit = swapAlpha(_intraSplit, upper, lower);\n            _interBound = swapAlpha(_interBound, upper, lower);\n            _intraBound = swapAlpha(_intraBound, upper, lower);\n            intraChars = swapAlpha(intraChars, upper, lower);\n            intraContr = swapAlpha(intraContr, upper, lower);\n        }\n\n        let uFlag = unicode ? 'u' : '';\n\n        const quotedAny = '\".+?\"';\n        const EXACTS_RE = new RegExp(quotedAny, 'gi' + uFlag);\n        const NEGS_RE = new RegExp(`(?:\\\\s+|^)-(?:${intraChars}+|${quotedAny})`, 'gi' + uFlag);\n\n        let { intraRules } = opts;\n\n        if (intraRules == null) {\n            intraRules = p => {\n                // default is exact term matches only\n                let _intraSlice = OPTS.intraSlice, // requires first char\n                    _intraIns = 0,\n                    _intraSub = 0,\n                    _intraTrn = 0,\n                    _intraDel = 0;\n\n                // only-digits strings should match exactly, else special rules for short strings\n                if (/[^\\d]/.test(p)) {\n                    let plen = p.length;\n\n                    // prevent junk matches by requiring stricter rules for short terms\n                    if (plen <= 4) {\n                        if (plen >= 3) {\n                            // one swap in non-first char when 3-4 chars\n                            _intraTrn = Math.min(intraTrn, 1);\n\n                            // or one insertion when 4 chars\n                            if (plen == 4)\n                                _intraIns = Math.min(intraIns, 1);\n                        }\n                        // else exact match when 1-2 chars\n                    }\n                    // use supplied opts\n                    else {\n                        _intraSlice = intraSlice;\n                        _intraIns = intraIns,\n                            _intraSub = intraSub,\n                            _intraTrn = intraTrn,\n                            _intraDel = intraDel;\n                    }\n                }\n\n                return {\n                    intraSlice: _intraSlice,\n                    intraIns: _intraIns,\n                    intraSub: _intraSub,\n                    intraTrn: _intraTrn,\n                    intraDel: _intraDel,\n                };\n            };\n        }\n\n        let withIntraSplit = !!_intraSplit;\n\n        let intraSplit = new RegExp(_intraSplit, 'g' + uFlag);\n        let interSplit = new RegExp(_interSplit, 'g' + uFlag);\n\n        let trimRe = new RegExp('^' + _interSplit + '|' + _interSplit + '$', 'g' + uFlag);\n        let contrsRe = new RegExp(intraContr, 'gi' + uFlag);\n\n        const split = needle => {\n            let exacts = [];\n\n            needle = needle.replace(EXACTS_RE, m => {\n                exacts.push(m);\n                return EXACT_HERE;\n            });\n\n            needle = needle.replace(trimRe, '').toLocaleLowerCase();\n\n            if (withIntraSplit)\n                needle = needle.replace(intraSplit, m => m[0] + ' ' + m[1]);\n\n            let j = 0;\n            return needle.split(interSplit).filter(t => t != '').map(v => v === EXACT_HERE ? exacts[j++] : v);\n        };\n\n        const NUM_OR_ALPHA_RE = /[^\\d]+|\\d+/g;\n\n        const prepQuery = (needle, capt = 0, interOR = false) => {\n            // split on punct, whitespace, num-alpha, and upper-lower boundaries\n            let parts = split(needle);\n\n            if (parts.length == 0)\n                return [];\n\n            // split out any detected contractions for each term that become required suffixes\n            let contrs = Array(parts.length).fill('');\n            parts = parts.map((p, pi) => p.replace(contrsRe, m => {\n                contrs[pi] = m;\n                return '';\n            }));\n\n            // array of regexp tpls for each term\n            let reTpl;\n\n            // allows single mutations within each term\n            if (intraMode == 1) {\n                reTpl = parts.map((p, pi) => {\n                    if (p[0] === '\"')\n                        return escapeRegExp(p.slice(1, -1));\n\n                    let reTpl = '';\n\n                    // split into numeric and alpha parts, so numbers are only matched as following punct or alpha boundaries, without swaps or insertions\n                    for (let m of p.matchAll(NUM_OR_ALPHA_RE)) {\n                        let p = m[0];\n\n                        let {\n                            intraSlice,\n                            intraIns,\n                            intraSub,\n                            intraTrn,\n                            intraDel,\n                        } = intraRules(p);\n\n                        if (intraIns + intraSub + intraTrn + intraDel == 0)\n                            reTpl += p + contrs[pi];\n                        else {\n                            let [lftIdx, rgtIdx] = intraSlice;\n                            let lftChar = p.slice(0, lftIdx); // prefix\n                            let rgtChar = p.slice(rgtIdx);    // suffix\n\n                            let chars = p.slice(lftIdx, rgtIdx);\n\n                            // neg lookahead to prefer matching 'Test' instead of 'tTest' in ManifestTest or fittest\n                            // but skip when search term contains leading repetition (aardvark, aaa)\n                            if (intraIns == 1 && lftChar.length == 1 && lftChar != chars[0])\n                                lftChar += '(?!' + lftChar + ')';\n\n                            let numChars = chars.length;\n\n                            let variants = [p];\n\n                            // variants with single char substitutions\n                            if (intraSub) {\n                                for (let i = 0; i < numChars; i++)\n                                    variants.push(lftChar + chars.slice(0, i) + intraChars + chars.slice(i + 1) + rgtChar);\n                            }\n\n                            // variants with single transpositions\n                            if (intraTrn) {\n                                for (let i = 0; i < numChars - 1; i++) {\n                                    if (chars[i] != chars[i+1])\n                                        variants.push(lftChar + chars.slice(0, i) + chars[i+1] + chars[i] + chars.slice(i + 2) + rgtChar);\n                                }\n                            }\n\n                            // variants with single char omissions\n                            if (intraDel) {\n                                for (let i = 0; i < numChars; i++)\n                                    variants.push(lftChar + chars.slice(0, i + 1) + '?' + chars.slice(i + 1) + rgtChar);\n                            }\n\n                            // variants with single char insertions\n                            if (intraIns) {\n                                let intraInsTpl = lazyRepeat(intraChars, 1);\n\n                                for (let i = 0; i < numChars; i++)\n                                    variants.push(lftChar + chars.slice(0, i) + intraInsTpl + chars.slice(i) + rgtChar);\n                            }\n\n                            reTpl += '(?:' + variants.join('|') + ')' + contrs[pi];\n                        }\n                    }\n\n                    //\tconsole.log(reTpl);\n\n                    return reTpl;\n                });\n            }\n            else {\n                let intraInsTpl = lazyRepeat(intraChars, intraIns);\n\n                // capture at char level\n                if (capt == 2 && intraIns > 0) {\n                    // sadly, we also have to capture the inter-term junk via parenth-wrapping .*?\n                    // to accum other capture groups' indices for \\b boosting during scoring\n                    intraInsTpl = ')(' + intraInsTpl + ')(';\n                }\n\n                reTpl = parts.map((p, pi) => p[0] === '\"' ? escapeRegExp(p.slice(1, -1)) :  p.split('').map((c, i, chars) => {\n                    // neg lookahead to prefer matching 'Test' instead of 'tTest' in ManifestTest or fittest\n                    // but skip when search term contains leading repetition (aardvark, aaa)\n                    if (intraIns == 1 && i == 0 && chars.length > 1 && c != chars[i+1])\n                        c += '(?!' + c + ')';\n\n                    return c;\n                }).join(intraInsTpl) + contrs[pi]);\n            }\n\n            //\tconsole.log(reTpl);\n\n            // this only helps to reduce initial matches early when they can be detected\n            // TODO: might want a mode 3 that excludes _\n            let preTpl = interLft == 2 ? mode2Tpl : '';\n            let sufTpl = interRgt == 2 ? mode2Tpl : '';\n\n            let interCharsTpl = sufTpl + lazyRepeat(opts.interChars, opts.interIns) + preTpl;\n\n            // capture at word level\n            if (capt > 0) {\n                if (interOR) {\n                    // this is basically for doing .matchAll() occurence counting and highlighting without needing permuted ooo needles\n                    reTpl = preTpl + '(' + reTpl.join(')' + sufTpl + '|' + preTpl + '(') + ')' + sufTpl;\n                }\n                else {\n                    // sadly, we also have to capture the inter-term junk via parenth-wrapping .*?\n                    // to accum other capture groups' indices for \\b boosting during scoring\n                    reTpl = '(' + reTpl.join(')(' + interCharsTpl + ')(') + ')';\n                    reTpl = '(.??' + preTpl + ')' + reTpl + '(' + sufTpl + '.*)'; // nit: trailing capture here assumes interIns = Inf\n                }\n            }\n            else {\n                reTpl = reTpl.join(interCharsTpl);\n                reTpl = preTpl + reTpl + sufTpl;\n            }\n\n            //\tconsole.log(reTpl);\n\n            return [new RegExp(reTpl, 'i' + uFlag), parts, contrs];\n        };\n\n        const filter = (haystack, needle, idxs) => {\n\n            let [query] = prepQuery(needle);\n\n            if (query == null)\n                return null;\n\n            let out = [];\n\n            if (idxs != null) {\n                for (let i = 0; i < idxs.length; i++) {\n                    let idx = idxs[i];\n                    query.test(haystack[idx]) && out.push(idx);\n                }\n            }\n            else {\n                for (let i = 0; i < haystack.length; i++)\n                    query.test(haystack[i]) && out.push(i);\n            }\n\n            return out;\n        };\n\n        let withIntraBound = !!_intraBound;\n\n        let interBound = new RegExp(_interBound, uFlag);\n        let intraBound = new RegExp(_intraBound, uFlag);\n\n        const info = (idxs, haystack, needle) => {\n\n            let [query, parts, contrs] = prepQuery(needle, 1);\n            let [queryR] = prepQuery(needle, 2);\n            let partsLen = parts.length;\n\n            let len = idxs.length;\n\n            let field = Array(len).fill(0);\n\n            let info = {\n                // idx in haystack\n                idx: Array(len),\n\n                // start of match\n                start: field.slice(),\n                // length of match\n                //\tspan: field.slice(),\n\n                // contiguous chars matched\n                chars: field.slice(),\n\n                // contiguous (no fuzz) and bounded terms (intra=0, lft2/1, rgt2/1)\n                // excludes terms that are contiguous but have < 2 bounds (substrings)\n                terms: field.slice(),\n\n                // cumulative length of unmatched chars (fuzz) within span\n                interIns: field.slice(), // between terms\n                intraIns: field.slice(), // within terms\n\n                // interLft/interRgt counters\n                interLft2: field.slice(),\n                interRgt2: field.slice(),\n                interLft1: field.slice(),\n                interRgt1: field.slice(),\n\n                ranges: Array(len),\n            };\n\n            // might discard idxs based on bounds checks\n            let mayDiscard = interLft == 1 || interRgt == 1;\n\n            let ii = 0;\n\n            for (let i = 0; i < idxs.length; i++) {\n                let mhstr = haystack[idxs[i]];\n\n                // the matched parts are [full, junk, term, junk, term, junk]\n                let m = mhstr.match(query);\n\n                // leading junk\n                let start = m.index + m[1].length;\n\n                let idxAcc = start;\n                //\tlet span = m[0].length;\n\n                let disc = false;\n                let lft2 = 0;\n                let lft1 = 0;\n                let rgt2 = 0;\n                let rgt1 = 0;\n                let chars = 0;\n                let terms = 0;\n                let inter = 0;\n                let intra = 0;\n\n                let refine = [];\n\n                for (let j = 0, k = 2; j < partsLen; j++, k+=2) {\n                    let group = m[k].toLocaleLowerCase();\n                    let part = parts[j];\n                    let term = part[0] == '\"' ? part.slice(1, -1) : part + contrs[j];\n                    let termLen = term.length;\n                    let groupLen = group.length;\n                    let fullMatch = group == term;\n\n                    // this won't handle the case when an exact match exists across the boundary of the current group and the next junk\n                    // e.g. blob,ob when searching for 'bob' but finding the earlier `blob` (with extra insertion)\n                    if (!fullMatch && m[k+1].length >= termLen) {\n                        // probe for exact match in inter junk (TODO: maybe even in this matched part?)\n                        let idxOf = m[k+1].toLocaleLowerCase().indexOf(term);\n\n                        if (idxOf > -1) {\n                            refine.push(idxAcc, groupLen, idxOf, termLen);\n                            idxAcc += refineMatch(m, k, idxOf, termLen);\n                            group = term;\n                            groupLen = termLen;\n                            fullMatch = true;\n\n                            if (j == 0)\n                                start = idxAcc;\n                        }\n                    }\n\n                    if (mayDiscard || fullMatch) {\n                        // does group's left and/or right land on \\b\n                        let lftCharIdx = idxAcc - 1;\n                        let rgtCharIdx = idxAcc + groupLen;\n\n                        let isPre = false;\n                        let isSuf = false;\n\n                        // prefix info\n                        if (lftCharIdx == -1           || interBound.test(mhstr[lftCharIdx])) {\n                            fullMatch && lft2++;\n                            isPre = true;\n                        }\n                        else {\n                            if (interLft == 2) {\n                                disc = true;\n                                break;\n                            }\n\n                            if (withIntraBound && intraBound.test(mhstr[lftCharIdx] + mhstr[lftCharIdx + 1])) {\n                                fullMatch && lft1++;\n                                isPre = true;\n                            }\n                            else {\n                                if (interLft == 1) {\n                                    // regexps are eager, so try to improve the match by probing forward inter junk for exact match at a boundary\n                                    let junk = m[k+1];\n                                    let junkIdx = idxAcc + groupLen;\n\n                                    if (junk.length >= termLen) {\n                                        let idxOf = 0;\n                                        let found = false;\n                                        let re = new RegExp(term, 'ig' + uFlag);\n\n                                        let m2;\n                                        while (m2 = re.exec(junk)) {\n                                            idxOf = m2.index;\n\n                                            let charIdx = junkIdx + idxOf;\n                                            let lftCharIdx = charIdx - 1;\n\n                                            if (lftCharIdx == -1 || interBound.test(mhstr[lftCharIdx])) {\n                                                lft2++;\n                                                found = true;\n                                                break;\n                                            }\n                                            else if (intraBound.test(mhstr[lftCharIdx] + mhstr[charIdx])) {\n                                                lft1++;\n                                                found = true;\n                                                break;\n                                            }\n                                        }\n\n                                        if (found) {\n                                            isPre = true;\n\n                                            // identical to exact term refinement pass above\n                                            refine.push(idxAcc, groupLen, idxOf, termLen);\n                                            idxAcc += refineMatch(m, k, idxOf, termLen);\n                                            group = term;\n                                            groupLen = termLen;\n                                            fullMatch = true;\n\n                                            if (j == 0)\n                                                start = idxAcc;\n                                        }\n                                    }\n\n                                    if (!isPre) {\n                                        disc = true;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n\n                        // suffix info\n                        if (rgtCharIdx == mhstr.length || interBound.test(mhstr[rgtCharIdx])) {\n                            fullMatch && rgt2++;\n                            isSuf = true;\n                        }\n                        else {\n                            if (interRgt == 2) {\n                                disc = true;\n                                break;\n                            }\n\n                            if (withIntraBound && intraBound.test(mhstr[rgtCharIdx - 1] + mhstr[rgtCharIdx])) {\n                                fullMatch && rgt1++;\n                                isSuf = true;\n                            }\n                            else {\n                                if (interRgt == 1) {\n                                    disc = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (fullMatch) {\n                            chars += termLen;\n\n                            if (isPre && isSuf)\n                                terms++;\n                        }\n                    }\n\n                    if (groupLen > termLen)\n                        intra += groupLen - termLen; // intraFuzz\n\n                    if (j > 0)\n                        inter += m[k-1].length; // interFuzz\n\n                    // TODO: group here is lowercased, which is okay for length cmp, but not more case-sensitive filts\n                    if (!opts.intraFilt(term, group, idxAcc)) {\n                        disc = true;\n                        break;\n                    }\n\n                    if (j < partsLen - 1)\n                        idxAcc += groupLen + m[k+1].length;\n                }\n\n                if (!disc) {\n                    info.idx[ii]       = idxs[i];\n                    info.interLft2[ii] = lft2;\n                    info.interLft1[ii] = lft1;\n                    info.interRgt2[ii] = rgt2;\n                    info.interRgt1[ii] = rgt1;\n                    info.chars[ii]     = chars;\n                    info.terms[ii]     = terms;\n                    info.interIns[ii]  = inter;\n                    info.intraIns[ii]  = intra;\n\n                    info.start[ii] = start;\n                    //\tinfo.span[ii] = span;\n\n                    // ranges\n                    let m = mhstr.match(queryR);\n\n                    let idxAcc = m.index + m[1].length;\n\n                    let refLen = refine.length;\n                    let ri = refLen > 0 ? 0 : Infinity;\n                    let lastRi = refLen - 4;\n\n                    for (let i = 2; i < m.length;) {\n                        let len = m[i].length;\n\n                        if (ri <= lastRi && refine[ri] == idxAcc) {\n                            let groupLen = refine[ri+1];\n                            let idxOf    = refine[ri+2];\n                            let termLen  = refine[ri+3];\n\n                            // advance to end of original (full) group match that includes intra-junk\n                            let j = i;\n                            let v = '';\n                            for (let _len = 0; _len < groupLen; j++) {\n                                v += m[j];\n                                _len += m[j].length;\n                            }\n\n                            m.splice(i, j - i, v);\n\n                            idxAcc += refineMatch(m, i, idxOf, termLen);\n\n                            ri += 4;\n                        }\n                        else {\n                            idxAcc += len;\n                            i++;\n                        }\n                    }\n\n                    idxAcc = m.index + m[1].length;\n\n                    let ranges = info.ranges[ii] = [];\n                    let from = idxAcc;\n                    let to = idxAcc;\n\n                    for (let i = 2; i < m.length; i++) {\n                        let len = m[i].length;\n\n                        idxAcc += len;\n\n                        if (i % 2 == 0)\n                            to = idxAcc;\n                        else if (len > 0) {\n                            ranges.push(from, to);\n                            from = to = idxAcc;\n                        }\n                    }\n\n                    if (to > from)\n                        ranges.push(from, to);\n\n                    ii++;\n                }\n            }\n\n            // trim arrays\n            if (ii < idxs.length) {\n                for (let k in info)\n                    info[k] = info[k].slice(0, ii);\n            }\n\n            return info;\n        };\n\n        const refineMatch = (m, k, idxInNext, termLen) => {\n            // shift the current group into the prior junk\n            let prepend = m[k] + m[k+1].slice(0, idxInNext);\n            m[k-1] += prepend;\n            m[k]    = m[k+1].slice(idxInNext, idxInNext + termLen);\n            m[k+1]  = m[k+1].slice(idxInNext + termLen);\n            return prepend.length;\n        };\n\n        const OOO_TERMS_LIMIT = 5;\n\n        // returns [idxs, info, order]\n        const _search = (haystack, needle, outOfOrder, infoThresh = 1e3, preFiltered) => {\n            outOfOrder = !outOfOrder ? 0 : outOfOrder === true ? OOO_TERMS_LIMIT : outOfOrder;\n\n            let needles = null;\n            let matches = null;\n\n            let negs = [];\n\n            needle = needle.replace(NEGS_RE, m => {\n                let neg = m.trim().slice(1);\n\n                neg = neg[0] === '\"' ? escapeRegExp(neg.slice(1,-1)) :  neg.replace(PUNCT_RE, '');\n\n                if (neg != '')\n                    negs.push(neg);\n\n                return '';\n            });\n\n            let terms = split(needle);\n\n            let negsRe;\n\n            if (negs.length > 0) {\n                negsRe = new RegExp(negs.join('|'), 'i' + uFlag);\n\n                if (terms.length == 0) {\n                    let idxs = [];\n\n                    for (let i = 0; i < haystack.length; i++) {\n                        if (!negsRe.test(haystack[i]))\n                            idxs.push(i);\n                    }\n\n                    return [idxs, null, null];\n                }\n            }\n            else {\n                // abort search (needle is empty after pre-processing, e.g. no alpha-numeric chars)\n                if (terms.length == 0)\n                    return [null, null, null];\n            }\n\n            //\tconsole.log(negs);\n            //\tconsole.log(needle);\n\n            if (outOfOrder > 0) {\n                // since uFuzzy is an AND-based search, we can iteratively pre-reduce the haystack by searching\n                // for each term in isolation before running permutations on what's left.\n                // this is a major perf win. e.g. searching \"test man ger pp a\" goes from 570ms -> 14ms\n                let terms = split(needle);\n\n                if (terms.length > 1) {\n                    // longest -> shortest\n                    let terms2 = terms.slice().sort((a, b) => b.length - a.length);\n\n                    for (let ti = 0; ti < terms2.length; ti++) {\n                        // no haystack item contained all terms\n                        if (preFiltered?.length == 0)\n                            return [[], null, null];\n\n                        preFiltered = filter(haystack, terms2[ti], preFiltered);\n                    }\n\n                    // avoid combinatorial explosion by limiting outOfOrder to 5 terms (120 max searches)\n                    // fall back to just filter() otherwise\n                    if (terms.length > outOfOrder)\n                        return [preFiltered, null, null];\n\n                    needles = permute(terms).map(perm => perm.join(' '));\n\n                    // filtered matches for each needle excluding same matches for prior needles\n                    matches = [];\n\n                    // keeps track of already-matched idxs to skip in follow-up permutations\n                    let matchedIdxs = new Set();\n\n                    for (let ni = 0; ni < needles.length; ni++) {\n                        if (matchedIdxs.size < preFiltered.length) {\n                            // filter further for this needle, exclude already-matched\n                            let preFiltered2 = preFiltered.filter(idx => !matchedIdxs.has(idx));\n\n                            let matched = filter(haystack, needles[ni], preFiltered2);\n\n                            for (let j = 0; j < matched.length; j++)\n                                matchedIdxs.add(matched[j]);\n\n                            matches.push(matched);\n                        }\n                        else\n                            matches.push([]);\n                    }\n                }\n            }\n\n            // interOR\n            //\tconsole.log(prepQuery(needle, 1, null, true));\n\n            // non-ooo or ooo w/single term\n            if (needles == null) {\n                needles = [needle];\n                matches = [preFiltered?.length > 0 ? preFiltered : filter(haystack, needle)];\n            }\n\n            let retInfo = null;\n            let retOrder = null;\n\n            if (negs.length > 0)\n                matches = matches.map(idxs => idxs.filter(idx => !negsRe.test(haystack[idx])));\n\n            let matchCount = matches.reduce((acc, idxs) => acc + idxs.length, 0);\n\n            // rank, sort, concat\n            if (matchCount <= infoThresh) {\n                retInfo = {};\n                retOrder = [];\n\n                for (let ni = 0; ni < matches.length; ni++) {\n                    let idxs = matches[ni];\n\n                    if (idxs == null || idxs.length == 0)\n                        continue;\n\n                    let needle = needles[ni];\n                    let _info = info(idxs, haystack, needle);\n                    let order = opts.sort(_info, haystack, needle);\n\n                    // offset idxs for concat'ing infos\n                    if (ni > 0) {\n                        for (let i = 0; i < order.length; i++)\n                            order[i] += retOrder.length;\n                    }\n\n                    for (let k in _info)\n                        retInfo[k] = (retInfo[k] ?? []).concat(_info[k]);\n\n                    retOrder = retOrder.concat(order);\n                }\n            }\n\n            return [\n                [].concat(...matches),\n                retInfo,\n                retOrder,\n            ];\n        };\n\n        return {\n            search: (...args) => {\n                let out = _search(...args);\n                return out;\n            },\n            split,\n            filter,\n            info,\n            sort: opts.sort,\n        };\n    }\n\n    const latinize = (() => {\n        let accents = {\n            A: 'ÁÀÃÂÄĄ',\n            a: 'áàãâäą',\n            E: 'ÉÈÊËĖ',\n            e: 'éèêëę',\n            I: 'ÍÌÎÏĮ',\n            i: 'íìîïį',\n            O: 'ÓÒÔÕÖ',\n            o: 'óòôõö',\n            U: 'ÚÙÛÜŪŲ',\n            u: 'úùûüūų',\n            C: 'ÇČĆ',\n            c: 'çčć',\n            L: 'Ł',\n            l: 'ł',\n            N: 'ÑŃ',\n            n: 'ñń',\n            S: 'ŠŚ',\n            s: 'šś',\n            Z: 'ŻŹ',\n            z: 'żź'\n        };\n\n        let accentsMap = new Map();\n        let accentsTpl = '';\n\n        for (let r in accents) {\n            accents[r].split('').forEach(a => {\n                accentsTpl += a;\n                accentsMap.set(a, r);\n            });\n        }\n\n        let accentsRe = new RegExp(`[${accentsTpl}]`, 'g');\n        let replacer = m => accentsMap.get(m);\n\n        return strings => {\n            if (typeof strings == 'string')\n                return strings.replace(accentsRe, replacer);\n\n            let out = Array(strings.length);\n            for (let i = 0; i < strings.length; i++)\n                out[i] = strings[i].replace(accentsRe, replacer);\n            return out;\n        };\n    })();\n\n    // https://stackoverflow.com/questions/9960908/permutations-in-javascript/37580979#37580979\n    function permute(arr) {\n        arr = arr.slice();\n\n        let length = arr.length,\n            result = [arr.slice()],\n            c = new Array(length).fill(0),\n            i = 1, k, p;\n\n        while (i < length) {\n            if (c[i] < i) {\n                k = i % 2 && c[i];\n                p = arr[i];\n                arr[i] = arr[k];\n                arr[k] = p;\n                ++c[i];\n                i = 1;\n                result.push(arr.slice());\n            } else {\n                c[i] = 0;\n                ++i;\n            }\n        }\n\n        return result;\n    }\n\n    const _mark = (part, matched) => matched ? `<mark>${part}</mark>` : part;\n    const _append = (acc, part) => acc + part;\n\n    function highlight(str, ranges, mark = _mark, accum = '', append = _append) {\n        accum = append(accum, mark(str.substring(0, ranges[0]), false)) ?? accum;\n\n        for (let i = 0; i < ranges.length; i+=2) {\n            let fr = ranges[i];\n            let to = ranges[i+1];\n\n            accum = append(accum, mark(str.substring(fr, to), true)) ?? accum;\n\n            if (i < ranges.length - 3)\n                accum = append(accum, mark(str.substring(ranges[i+1], ranges[i+2]), false)) ?? accum;\n        }\n\n        accum = append(accum, mark(str.substring(ranges[ranges.length - 1]), false)) ?? accum;\n\n        return accum;\n    }\n\n    uFuzzy.latinize = latinize;\n    uFuzzy.permute = arr => {\n        let idxs = permute([...Array(arr.length).keys()]).sort((a,b) => {\n            for (let i = 0; i < a.length; i++) {\n                if (a[i] != b[i])\n                    return a[i] - b[i];\n            }\n            return 0;\n        });\n\n        return idxs.map(pi => pi.map(i => arr[i]));\n    };\n    uFuzzy.highlight = highlight;\n\n    return uFuzzy;\n\n})();\n\nexport default {\n    uFuzzy,\n};\n"],"names":["uFuzzy","cmp","Intl","Collator","numeric","sensitivity","compare","inf","Infinity","escapeRegExp","str","replace","PUNCT_RE","swapAlpha","upper","lower","OPTS","unicode","alpha","interSplit","intraSplit","interBound","intraBound","interLft","interRgt","interChars","interIns","intraChars","intraIns","intraContr","intraMode","intraSlice","intraSub","intraTrn","intraDel","intraFilt","term","match","index","sort","info","haystack","needle","idx","chars","terms","interLft2","interLft1","start","map","v","i","ia","ib","lazyRepeat","limit","opts","Object","assign","_intraSplit","_interSplit","_intraBound","_interBound","letters","toLocaleUpperCase","toLocaleLowerCase","uFlag","EXACTS_RE","RegExp","NEGS_RE","intraRules","p","_intraSlice","_intraIns","_intraSub","_intraTrn","_intraDel","test","plen","length","Math","min","withIntraSplit","trimRe","contrsRe","split","exacts","m","push","j","filter","t","NUM_OR_ALPHA_RE","prepQuery","capt","interOR","parts","reTpl","contrs","Array","fill","pi","slice","matchAll","lftIdx","rgtIdx","lftChar","rgtChar","numChars","variants","intraInsTpl","join","c","preTpl","sufTpl","interCharsTpl","idxs","query","out","withIntraBound","queryR","partsLen","len","field","interRgt2","interRgt1","ranges","mayDiscard","ii","mhstr","idxAcc","disc","lft2","lft1","rgt2","rgt1","inter","intra","refine","k","group","part","termLen","groupLen","fullMatch","idxOf","indexOf","refineMatch","lftCharIdx","rgtCharIdx","isPre","isSuf","junk","junkIdx","m2","found","re","exec","charIdx","refLen","ri","lastRi","_len","splice","from","to","idxInNext","prepend","_search","outOfOrder","infoThresh","preFiltered","needles","matches","negs","neg","trim","negsRe","terms2","a","b","ti","permute","perm","matchedIdxs","Set","ni","size","preFiltered2","has","matched","add","retInfo","retOrder","matchCount","reduce","acc","_info","order","concat","search","latinize","accents","A","E","e","I","O","o","U","u","C","L","l","N","n","S","s","Z","z","accentsMap","Map","accentsTpl","r","forEach","set","accentsRe","replacer","get","strings","arr","result","_mark","_append","keys","highlight","mark","accum","append","substring","fr"],"mappings":"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"}